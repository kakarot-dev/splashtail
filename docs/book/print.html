<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AntiRaid Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="user/permissions/index.html"><strong aria-hidden="true">1.</strong> Permissions</a></li><li class="chapter-item expanded "><a href="user/templating/index.html"><strong aria-hidden="true">2.</strong> Templating</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user/templating/1-intro.html"><strong aria-hidden="true">2.1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="user/templating/2-plugins.html"><strong aria-hidden="true">2.2.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="user/templating/3-example.html"><strong aria-hidden="true">2.3.</strong> A Simple Example</a></li><li class="chapter-item expanded "><a href="user/templating/4-luau-ecosystem.html"><strong aria-hidden="true">2.4.</strong> Ecosystem</a></li></ol></li><li class="chapter-item expanded "><a href="user/captcha/index.html"><strong aria-hidden="true">3.</strong> Captcha</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user/captcha/1-intro.html"><strong aria-hidden="true">3.1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="user/captcha/2-examples.html"><strong aria-hidden="true">3.2.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="user/lockdown/index.html"><strong aria-hidden="true">4.</strong> Lockdown</a></li><li class="chapter-item expanded "><a href="user/modifiers/1-modifiers.html"><strong aria-hidden="true">5.</strong> Modifiers</a></li><li class="chapter-item expanded "><a href="user/backups/index.html"><strong aria-hidden="true">6.</strong> Backups</a></li><li class="chapter-item expanded affix "><li class="part-title">Developer Guide</li><li class="chapter-item expanded "><a href="dev/go_jobs/index.html"><strong aria-hidden="true">7.</strong> Go Jobserver</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/go_jobs/backups.html"><strong aria-hidden="true">7.1.</strong> Backups</a></li></ol></li><li class="chapter-item expanded "><a href="dev/rust_bot_modules_lockdown/index.html"><strong aria-hidden="true">8.</strong> Lockdown Module</a></li><li class="chapter-item expanded "><a href="dev/rust_silverpelt/index.html"><strong aria-hidden="true">9.</strong> Silverpelt</a></li><li class="chapter-item expanded "><a href="dev/rust_templating/index.html"><strong aria-hidden="true">10.</strong> Templating</a></li><li class="chapter-item expanded "><a href="dev/rust_text/index.html"><strong aria-hidden="true">11.</strong> Text</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">AntiRaid Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="anti-raid-documentation"><a class="header" href="#anti-raid-documentation">Anti-Raid Documentation</a></h1>
<p>This is the documentation for the Anti-Raid bot.configure multiple CAPTCHA types and settings to suit your server's requirements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="permissions"><a class="header" href="#permissions">Permissions</a></h1>
<p>Imagine. Imagine a discord bot which you could completely control. You could decide who can use any specific command, who can change the bot's settings, and who can even use the bot at all.</p>
<p><em>Thats AntiRaid...</em></p>
<p>AntiRaid has a customizable permission system utilizing both Discord native permissions for ease of use and <a href="https://github.com/InfinityBotList/kittycat">kittycat</a> for more complex use cases. And for the really unique cases, AntiRaid provides support for Lua script templating which case be used to extend AntiRaid into more complex/unique permission systems itself.</p>
<p>The idea is simple: All roles have permissions attached to them and members can have special permission overrides on top of that. The permissions are then checked when a command is run.</p>
<p><strong>Note:</strong> The documentation for this is not yet finished and is a WIP.</p>
<h2 id="modes"><a class="header" href="#modes">Modes</a></h2>
<p>Anti-Raid has two different modes for permission checks depending on how custom your needs are:</p>
<ul>
<li><code>Simple</code>: In simple mode, you just need to specify the exact permissions needed to run a command. This is the default mode.</li>
<li><code>Template</code>: If you have more advanced needs, you can also use custom templates to determine if a user has the required permissions. See <a href="user/permissions/../templating-lua/1-intro.html"><code>Templating</code></a> for more information on how templating works.</li>
</ul>
<h2 id="simple-permission-checks"><a class="header" href="#simple-permission-checks">Simple Permission Checks</a></h2>
<p>Since not everyone knows how to code, AntiRaid provides a simple permission checking system builtin that should be enough for most. Heres how it works:</p>
<ol>
<li>Commands are the base primitive of AntiRaid. These commands can be either real or virtual. Real commands are commands that you can actually run (as well as configure) while virtual commands are placeholders for permissions, help commands or external modules that don't use the normal AntiRaid module system [e.g. modules written in Gleam].</li>
<li>Commands can be configured through either permissions or by simply disabling them (some commands cannot be disabled however to ensure you can't break the bot permanently).</li>
<li>Server admins can set permissions on their server roles and then override them for specific users through permission overrides.</li>
<li>Server admins can then set permissions on commands and default permissions on modules. These permissions are then checked when a command is run.</li>
</ol>
<p>Of course, the above is just an overview of AntiRaid permission system. This is just an overview, of course.</p>
<h2 id="template-permission-checks"><a class="header" href="#template-permission-checks">Template Permission Checks</a></h2>
<p>For more advanced users, AntiRaid provides a template system that allows you to create custom permission checks. This is done through the use of our custom Luau templating system.</p>
<p>See the <a href="user/permissions/../templating-lua/1-intro.html">templating guide</a> for more information on how to use Lua templates. Then, just code away!</p>
<h2 id="tip"><a class="header" href="#tip">TIP</a></h2>
<p>For best results, consider limiting server permissions of other users to the minimum required. Then, use AntiRaid for actual moderation. That's better than giving everyone admin permissions and then trying to restrict them with AntiRaid and also allows AntiRaid to work fully!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templating"><a class="header" href="#templating">Templating</a></h1>
<p>At AntiRaid, we prioritize flexibility and customization for our users. To this end, our bot supports advanced templating to allow for extensive personalization of embeds and messages. While many bots utilize proprietary languages or templating engines, we have chosen to leverage Lua—a renowned scripting language widely used in game development and other applications. This decision ensures that our users benefit from a powerful, well-documented, and versatile language, enhancing the capability and ease of customizing their AntiRaid experience.</p>
<p><strong>Note: this documentation is still a work-in-progress and things are still being documented better and better by the day!</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lua-templating"><a class="header" href="#lua-templating">Lua Templating</a></h1>
<p>At AntiRaid, we prioritize flexibility and customization for our users. To this end, our bot supports advanced templating to allow for extensive personalization of embeds and messages. While many bots utilize proprietary languages or templating engines, we have chosen to leverage Lua—a renowned scripting language widely used in game development and other applications. This decision ensures that our users benefit from a powerful, well-documented, and versatile language, enhancing the capability and ease of customizing their AntiRaid experience.</p>
<p>Specifically, Anti Raid uses a variant of Lua called Luau. If you've ever used Roblox before, this is the same variant of Lua used there too (which is why Luau is also known as Roblox Lua in many places). You can check out the <a href="https://luau-lang.org/">Luau docs</a> for more information on the language itself. Unlike PUC Lua (the reference implementation), Luau is both faster and offers robust sandboxing capabilities allowing AntiRaid to run scripts in as safe an environment as possible.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Note that the remainder of these docs will cover AntiRaids Lua SDKs. To learn more about Lua itself, please checkout Lua's official tutorial for Lua 5.0 <a href="https://www.lua.org/pil/1.html">here</a>. Other resources for Lua exist (Lua is very popular after all), including <a href="https://devforum.roblox.com/t/lua-scripting-starter-guide/394618#print-5">Roblox's tutorial</a> (ignore the Studio bits), <a href="https://www.tutorialspoint.com/lua/lua_quick_guide.htm">TutorialPoint</a> and <a href="https://www.codecademy.com/learn/learn-lua">Codecademy</a>.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>AntiRaid applies the following 3 global limits to all Lua templates. Note that we may provide increased limits as a Premium feature in the future:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const MAX_TEMPLATE_MEMORY_USAGE: usize = 1024 * 1024 * 3; // 3MB maximum memory
pub const MAX_TEMPLATE_LIFETIME: std::time::Duration = std::time::Duration::from_secs(60 * 15); // 15 minutes maximum lifetime
pub const MAX_TEMPLATES_EXECUTION_TIME: std::time::Duration = std::time::Duration::from_secs(30); // 30 seconds maximum execution time
<span class="boring">}</span></code></pre></pre>
<p>The above limits are in place to prevent abuse and ensure that the bot remains responsive. If you require increased limits, please contact support (once again, this may change in the future).</p>
<h2 id="some-key-notes"><a class="header" href="#some-key-notes">Some key notes</a></h2>
<ul>
<li>Each guild is assigned a dedicated Lua VM. This VM is used to execute Lua code that is used in the templates.</li>
<li>The total memory usage that a guild can use is limited to <code>MAX_TEMPLATE_MEMORY_USAGE</code> (currently 3MB). This is to prevent a single guild from using too much memory.</li>
<li>Execution of all scripts is timed out when the last executed script takes longer than <code>MAX_TEMPLATES_EXECUTION_TIME</code> (currently 30 seconds).</li>
<li>A lua VM will exist for a total of <code>MAX_TEMPLATE_LIFETIME</code> (currently 10 minutes) after the last access before being destroyed. This is to reduce memory+CPU usage.</li>
<li>The <code>__stack</code> table can be used to share data across templates safely <em>while the VM is running</em>. without affecting other templates. This is useful for sharing data between templates such as Audit Logs. <strong>Note that AntiRaid uses luau sandboxing meaning that <code>_G</code> is readonly.</strong></li>
<li>The standard <code>require</code> statement can be used to import AntiRaid modules. <strong>Note that the modules are read-only</strong> and cannot be monkey-patched etc.</li>
<li><strong>Because Lua is a single-threaded language, only one template can be executed at a time</strong></li>
</ul>
<p>There are 2 valid syntax for a Luau template:</p>
<ol>
<li>Lua script syntax</li>
</ol>
<pre><code class="language-lua">local args, token = ...
-- Do something
return output
</code></pre>
<ol start="2">
<li>Function expression syntax (not recommended for new code)</li>
</ol>
<pre><code class="language-lua">function(args, token)
    -- Do something
    return output
end
</code></pre>
<p>Note that option 1 is recommended as it is both more idiomatic and is also valid syntax for LSP's and Luau parsers. Note that option 2 is actually converted to option 1 internally through the below wrapper:</p>
<pre><code>local args, token = ...
{function body here}
</code></pre>
<h2 id="interop"><a class="header" href="#interop">Interop</a></h2>
<p>Many features of Lua don't work so well when calling functions within the AntiRaid SDK. For example, both arrays and maps are expressed as tables in Lua. However, AntiRaid, being written in Rust, doesn't know this and hance needs some help to convert certain types for FFI. This is where the <code>@antiraid/interop</code> module comes in.</p>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>To pass arrays to modules within the AntiRaid SDK, you need to set the metatable to <code>@antiraid/interop#array_metatable</code>. This will allow the SDK to convert the array to a Rust <code>Vec</code> internally.</p>
<pre><code class="language-lua">local interop = require '@antiraid/interop'
setmetatable({a = 5}, interop.array_metatable)
</code></pre>
<h3 id="null"><a class="header" href="#null">Null</a></h3>
<p>While the Lua <code>nil</code> does work in many cases (and even when calling the SDK), its not the best choice. When querying AntiRaid SDK, the SDK will use the <code>@antiraid/interop#null</code> value to represent a null value. Your Lua templates can also use this value if desired</p>
<pre><code class="language-lua">local interop = require '@antiraid/interop'
local null = interop.null -- This is the null value
</code></pre>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<p>While not strictly useful for interop, it is often desirable to know the memory usage of a Lua template as AntiRaid will kill your template if it exceeds the memory limit. For this, you can use the <code>@antiraid/interop#memusage</code> function.</p>
<pre><code class="language-lua">local interop = require '@antiraid/interop'
print(interop.memusage())
</code></pre>
<h3 id="user-error-vs-runtime-error"><a class="header" href="#user-error-vs-runtime-error">User Error vs Runtime Error</a></h3>
<p>As Lua does not have a built-in way to distinguish between user errors and runtime errors, AntiRaid provides a way to do so. Simply return a table with the key <code>__error</code> set, and the value set to the error message to create a user error. You can use the standard <code>error</code> function for runtime errors. E.g.</p>
<pre><code class="language-lua">-- User Error
return { __error = "You have reached the maximum number of tries in this 5 minute window." }

-- Runtime Error
error("Could not parse user ID for some reason")
</code></pre>
<h2 id="template-tokens"><a class="header" href="#template-tokens">Template Tokens</a></h2>
<p>All Lua templates include a special template token in addition to the template arguments. "Executors" use this token to get access to the low-level per-template state. Examples of executors include the <code>@antiraid/actions</code> <code>ActionExecutor</code>, which allows you to perform actions such as banning/kicking/timing out users and other Discord actions and <code>@antiraid/kv</code> <code>KvExecutor</code> which allow for persistent storage via a key-value interface.</p>
<p>Note that token is randomly generated for each <em>template invocation</em> and is only guaranteed to be valid during a template execution. It is also guaranteed, however, that the created executor is complete and does not rely on the token itself whatsoever after creation. This means that a template executor can be used after the template has finished executing (e.g. in a coroutine).</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-lua">local args, token = ...
print(token)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="antiraid-plugins"><a class="header" href="#antiraid-plugins">AntiRaid Plugins</a></h1>
<h2 id="builtins"><a class="header" href="#builtins">Builtins</a></h2>
<p><strong>Module Name:</strong> <code>@antiraid/builtins</code></p>
<p>Provides some basic builtins for AntiRaid.</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<ul>
<li><code>require(module_name: string, args: Option&lt;table&gt;) -&gt; table&lt;any&gt;</code></li>
</ul>
<p><code>args</code> is an optional table of arguments to pass to the module:</p>
<ul>
<li><code>plugin_cache</code> (bool) -&gt; whether or not to cache the plugin / load the plugin from cache, may improve performance.</li>
</ul>
<h2 id="async"><a class="header" href="#async">Async</a></h2>
<p><strong>Module Name:</strong> <code>@antiraid/async</code></p>
<p>Provides basic async primitives</p>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<ul>
<li><code>sleep(duration: f64)</code></li>
</ul>
<p>Pauses execution for the specified duration in seconds. Note that the duration passed to sleep <em>cannot</em> exeed the maximum VM lifetime.</p>
<h2 id="interop-1"><a class="header" href="#interop-1">Interop</a></h2>
<p><strong>Module Name:</strong> <code>@antiraid/interop</code></p>
<p>Interop between Lua and the Rust core</p>
<h3 id="values"><a class="header" href="#values">Values</a></h3>
<ul>
<li><code>null</code></li>
</ul>
<p>While the Lua <code>nil</code> does work in many cases (and even when calling the SDK), its not the best choice. When querying AntiRaid SDK, the SDK will use the <code>@antiraid/interop#null</code> value to represent a null value. Lua templates can also use this value if desired.</p>
<p>One advantage of <code>null</code> vs <code>nil</code> is that <code>null</code> can be used to check whether a value is set but is null or is completely unset. <code>nil</code> can only be used to check if a value is unset. This is important when interfacing with Discord as Discord often has differing semantics between non-existence and existing-but-null such as in Gateway Events.</p>
<ul>
<li><code>array_metatable</code></li>
</ul>
<p>To pass arrays to modules within the AntiRaid SDK, you need to set the metatable to <code>@antiraid/interop#array_metatable</code>. This will allow the SDK to convert the array to a Rust <code>Vec</code> internally.</p>
<pre><code class="language-lua">local interop = require '@antiraid/interop'
setmetatable({a = 5}, interop.array_metatable)
</code></pre>
<p>This is required because tables in Lua can represent both a hashmap and an array so the metadata is required to know which to choose,</p>
<h3 id="functions-2"><a class="header" href="#functions-2">Functions</a></h3>
<ul>
<li><code>memusage() -&gt; number</code></li>
</ul>
<p>While not strictly useful for interop, it is often desirable to know the memory usage of a Lua template as AntiRaid will kill your template if it exceeds the memory limit. For this, you can use the <code>@antiraid/interop#memusage</code> function.</p>
<pre><code class="language-lua">local interop = require '@antiraid/interop'
print(interop.memusage())
</code></pre>
<p>This function returns the memory usage of the VM in bytes.</p>
<ul>
<li><code>guild_id() -&gt; string</code></li>
</ul>
<p>This function returns the guilq id of the current context for templating.</p>
<h2 id="formatters"><a class="header" href="#formatters">Formatters</a></h2>
<p><strong>Module Name:</strong> <code>@antiraid/formatters</code></p>
<p>Functions for creating templated messages</p>
<h3 id="functions-3"><a class="header" href="#functions-3">Functions</a></h3>
<ul>
<li><code>format_gwevent_field(field: table&lt;gwevent.field.Field&gt;) -&gt; String</code></li>
</ul>
<p>Formats a gwevent field into a string. These are exposed in places such as Audit Logs and other areas.</p>
<h2 id="permissions-1"><a class="header" href="#permissions-1">Permissions</a></h2>
<p><strong>Module Name:</strong> <code>@antiraid/permissions</code></p>
<p>Provides functions for checking and handling permissions. Internally, this exposes (parts of) the <code>kittycat</code> and <code>rust.permissions</code> crates for Lua templating.</p>
<h3 id="functions-4"><a class="header" href="#functions-4">Functions</a></h3>
<ul>
<li><code>new_permission_check() -&gt; table&lt;permissions.PermissionCheck&gt;</code></li>
</ul>
<p>Creates a new permission check table</p>
<ul>
<li><code>new_permission_checks() -&gt; table&lt;permissions.PermissionChecks&gt;</code></li>
</ul>
<p>Creates a new permission checks table. This is not very useful (theres only two variants: <code>Simple</code> and <code>Template</code>) but is exposed for the sake of completeness.</p>
<ul>
<li><code>new_permission(namespace: string, perm: string, negator: boolean) -&gt; table&lt;kittycat.perms.Permission&gt;</code></li>
</ul>
<p>Creates a new kittycat permission table given the namespace, permission and negator.</p>
<ul>
<li><code>new_permission_from_string(perm: string) -&gt; table&lt;kittycat.perms.Permission&gt;</code></li>
</ul>
<p>Given the string form of a kittycat permission, creates a new permission table.</p>
<ul>
<li><code>permission_to_string(perm: table&lt;kittycat.perms.Permission&gt;) -&gt; string</code></li>
</ul>
<p>Converts a kittycat permission to its string form.</p>
<ul>
<li><code>has_perm(permissions: {table&lt;kittycat.perms.Permission&gt;}, perm: table&lt;kittycat.perms.Permission&gt;) -&gt; boolean</code></li>
</ul>
<p>Checks if a list of permissions 'has' a specific permission. This corresponds to <code>kittycat::perms::has_perm(permissions, perm)</code>.</p>
<ul>
<li><code>has_perm_str(permissions: {string}, perm: string) -&gt; boolean</code></li>
</ul>
<p>The string variant of <code>has_perm</code>. This is useful when you have a list of permissions in string form. This corresponds to <code>kittycat::perms::has_perm_str(permissions, perm)</code>.</p>
<ul>
<li><code>check_perms_single(check: permissions.PermissionCheck, member_native_perms: serenity.all.Permissions, member_kittycat_perms: {kittycat.perms.Permission}) -&gt; LuaPermissionResult</code></li>
</ul>
<p>Checks a single permission check. This corresponds to <code>permissions::check_perms_single(check, member_native_perms, member_kittycat_perms)</code>.</p>
<ul>
<li><code>eval_checks(checks: {permissions.PermissionCheck}, member_native_perms: serenity.all.Permissions, member_kittycat_perms: {kittycat.perms.Permission}) -&gt; LuaPermissionResult</code></li>
</ul>
<p>Checks a set of permission checks. This corresponds to <code>permissions::eval_checks(checks, member_native_perms, member_kittycat_perms)</code>.</p>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>The following rust types are exposed to Lua:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LuaPermissionResult {
    /// The raw result of the permission check
    pub result: PermissionResult,
    /// Whether the permission result represents a success or a failure
    pub is_ok: bool,
    /// The code of the permission result
    pub code: String,
    /// The markdown representation of the permission result
    pub markdown: String,
}

#[serde(tag = "var")]
pub enum PermissionResult {
    Ok {},
    OkWithMessage { message: String },
    MissingKittycatPerms { check: PermissionCheck },
    MissingNativePerms { check: PermissionCheck },
    MissingAnyPerms { check: PermissionCheck },
    CommandDisabled { command: String },
    UnknownModule { module: String },
    ModuleNotFound {},
    ModuleDisabled { module: String },
    NoChecksSucceeded { checks: PermissionChecks },
    DiscordError { error: String },
    SudoNotGranted {},
    GenericError { error: String },
}

pub struct PermissionCheck {
    /// The kittycat permissions needed to run the command
    pub kittycat_perms: Vec&lt;String&gt;,
    /// The native permissions needed to run the command
    pub native_perms: Vec&lt;serenity::all::Permissions&gt;,
    /// Whether the next permission check should be ANDed (all needed) or OR'd (at least one) to the current
    pub outer_and: bool,
    /// Whether or not the perms are ANDed (all needed) or OR'd (at least one)
    pub inner_and: bool,
}

pub enum PermissionChecks {
    Simple {
        /// The list of permission checks
        checks: Vec&lt;PermissionCheck&gt;,
    },
    Template {
        /// The template string to use
        template: String,
    },
}

/// Represents an embed field
pub struct MessageEmbedField {
    /// The name of the field
    pub name: String,
    /// The value of the field
    pub value: String,
    /// Whether the field is inline
    pub inline: bool,
}

/// Represents a message embed
pub struct MessageEmbed {
    /// The title set by the template
    pub title: Option&lt;String&gt;,
    /// The description set by the template
    pub description: Option&lt;String&gt;,
    /// The fields that were set by the template
    pub fields: Vec&lt;MessageEmbedField&gt;,
}

/// Represents a message that can be created by templates
pub struct Message {
    /// Embeds [current_index, embeds]
    pub embeds: Vec&lt;MessageEmbed&gt;,
    /// What content to set on the message
    pub content: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-templates"><a class="header" href="#example-templates">Example Templates</a></h1>
<p>To help you get started with templating, we have provided a few examples below along with explanations of what/how they work</p>
<h2 id="example-1-simple-audit-logging"><a class="header" href="#example-1-simple-audit-logging">Example 1: Simple Audit Logging</a></h2>
<h3 id="explanation"><a class="header" href="#explanation">Explanation</a></h3>
<h4 id="1-pragma"><a class="header" href="#1-pragma">1. Pragma</a></h4>
<p>The first line of the template is a pragma. This is a special statement beginning with <code>@pragma</code> or <code>-- @pragma</code> that tells AntiRaid what language the template is written in, what options to use, and how tools such as CI, websites and other automation should handle your template. The rest of the pragma is a JSON object that contains the options. Note that if you do not provide a pragma, a default one will be used, however this will not allow you to provide capabilities to your template such as sending a message on Discord etc.</p>
<p>In this case, we want to tell AntiRaid that we are coding a template in Lua and that we want to allow the capability to send messages to Discord. This is done by adding the <code>allowed_caps</code> key to the pragma and specifying the capabilities we want to allow as seen below:</p>
<pre><code class="language-lua">-- @pragma {"lang":"lua","allowed_caps":["discord:sendmessage_channel"]}
</code></pre>
<p>Another example of pragma is on the Website:</p>
<p><img src="user/templating/3-example-pragmaimg.png" alt="Pragma on website image" /></p>
<pre><code class="language-json">{"lang":"lua","builderInfo":{"ver":1,"data":{"embeds":[{"title":"Test","description":"","fields":[]}],"content":""},"checksum":"72e7225dfa2725a979fccc763e2e5bac3855f1cd3c10b5cd00c90b53e724db23"},"allowed_caps":["discord:sendmessage_channel"]}
</code></pre>
<p>Here, notice that the builderInfo contains the embeds, content, and checksum of the template. When the user wants to reread their template, the website only has to reread the pragma statement to reconstruct the state and show the right tab (either Builder if they are just making a simple embed, or Advanced if they were making changes to the content of the template itself). Without the pragma, the website would have to use its own arcane syntax on top of comments or execute the template just to reconstruct state.</p>
<h4 id="2-creating-a-message"><a class="header" href="#2-creating-a-message">2. Creating a message</a></h4>
<p>Next, we need to extract the arguments and token from the context. The arguments are passed to the template when it is executed and contain all the data we need to work with. The token is used to authenticate the template and gain access to the templates context in privileged AntiRaid API's. All of this is provided using variable arguments.</p>
<pre><code class="language-lua">local args, token = ...
</code></pre>
<p>There are 3 things we want to import for this template to work. The first is the Discord module, which allows us to send messages to Discord. The second is the Interop module, which provides some functions allowing for seamless interoperability between your template and AntiRaid. The third is the Formatters module, which provides some helper methods for formatting audit log fields (formally known as <code>gwevent_fields</code>).</p>
<pre><code class="language-lua">local discord = require "@antiraid/discord"
local interop = require "@antiraid/interop"
local formatter = require "@antiraid/formatters"
</code></pre>
<p>Next, we create the embed. <code>args.event_titlename</code> is specific to Audit Logs and contains the friendly name for an event.</p>
<pre><code class="language-lua">-- Make the embed
local embed = {
    title = args.event_titlename, 
    description = "", -- Start with empty description
}
</code></pre>
<p><strong>NOTE: You can use the <a href="user/templating/./2-plugins.html">API Reference</a> to see what functions are available in the AntiRaid SDK</strong></p>
<h4 id="3-adding-fields"><a class="header" href="#3-adding-fields">3. Adding fields</a></h4>
<p><strong>TIP: When making a template for a Gateway Event, the fields are passed to the template through a table named <code>fields</code>.</strong></p>
<p>The next step is to add fields to the embed. In this case, we can do this by iterating over <code>fields</code>. In Lua, tables can be iterated over using the builtin <code>pairs</code> function like below:</p>
<pre><code class="language-lua">for key, value in pairs(my_table) do
    -- Do something with key and value
end
</code></pre>
<p>In the same way, we can now iterate over <code>args.event_data</code>:</p>
<pre><code class="language-lua">for key, value in pairs(args.event_data) do
    -- Do something with key and value
end
</code></pre>
<p>When using Audit Log Events, there are two cases to pay attention to, the first is the field itself being <code>nil</code> and the second is the field type being <code>None</code>. In both cases, we don't want to add the field to the embed. Lets do that!</p>
<pre><code class="language-lua">local should_set = false

if value ~= nil and value.field.type ~= "None" then
    should_set = true
end
</code></pre>
<p>Lastly, we need to format the field and add it to the description. Luckily, the formatter plugin provides a function for formatting any categorized field. This function is called <code>format_gwevent_field</code>.</p>
<pre><code class="language-lua">local formatted_value = formatter.format_gwevent_field(value)
</code></pre>
<h4 id="4-sending-the-message"><a class="header" href="#4-sending-the-message">4. Sending the message</a></h4>
<p>Finally, we can send the message using the Discord module. To do this, we need to create a message object and set the embeds property to an array containing our embed. This is also where interop comes in handy, as we need to set the metatable of the embeds array to the interop array metatable so AntiRaid knows that embeds is an array. Next, we use the Discord plugin to make a new Discord action executor which then lets us send the message to the specified channel (<code>args.sink</code> is another Audit Log specific variable that contains the channel ID/whatever <code>sink</code> is set to in the database).</p>
<pre><code class="language-lua">local message = { embeds = {} }
setmetatable(message.embeds, interop.array_metatable)

table.insert(message.embeds, embed)

-- Send message using action executor
local discord_executor = discord.new(token);
discord_executor:sendmessage_channel({
    channel_id = args.sink,
    message = message
})
</code></pre>
<p>Finally, we can put the entire loop together as so:</p>
<pre><code class="language-lua">-- @pragma {"lang":"lua","allowed_caps":["discord:sendmessage_channel"]}
local args, token = ...
local discord = require "@antiraid/discord"
local interop = require "@antiraid/interop"
local formatter = require "@antiraid/formatters"

-- Make the embed
local embed = {
    title = args.event_titlename, 
    description = "", -- Start with empty description
}

-- Add the event data to the description
for key, value in pairs(args.event_data) do
    local should_set = false

    if value ~= nil and value.type ~= "None" then
        should_set = true
    end

    if should_set then
        local formatted_value = formatter.format_gwevent_field(value)
        embed.description = embed.description .. "**" .. key:gsub("_", " "):upper() .. "**: " .. formatted_value .. "\n"
    end
end

local message = { embeds = {} }
setmetatable(message.embeds, interop.array_metatable)

table.insert(message.embeds, embed)

-- Send message using action executor
local discord_executor = discord.new(token);
discord_executor:sendmessage_channel({
    channel_id = args.sink,
    message = message
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="luau-ecosystem-integration-notes"><a class="header" href="#luau-ecosystem-integration-notes">Luau Ecosystem Integration Notes</a></h1>
<p>At AntiRaid, we believe that bot developers should be able to access the best tools available to them. To this end, we have integrated some popular Luau libraries into our templating environment to provide a more powerful and flexible experience while taking into account security and stability of the bot. Below, we outline the libraries that are currently available for use in your Lua templates:</p>
<h2 id="libraries"><a class="header" href="#libraries">Libraries</a></h2>
<ul>
<li><a href="https://lune-org.github.io/docs/api-reference/datetime"><strong>@lune/datetime</strong></a></li>
<li><a href="https://lune-org.github.io/docs/api-reference/regex"><strong>@lune/regex</strong></a></li>
<li><a href="https://lune-org.github.io/docs/api-reference/serde"><strong>@lune/serde</strong></a></li>
</ul>
<h2 id="legal-disclaimer"><a class="header" href="#legal-disclaimer">Legal Disclaimer</a></h2>
<p>AntiRaid is not affiliated with any of the libraries mentioned above. We do not claim ownership of these libraries or their trademarks whatsoever, nor do we provide any guarantees or warranties regarding their functionality. AntiRaid absolves all liability for any damages or losses incurred through the use of these libraries, both to the libraries owner and to AntiRaid itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="captcha"><a class="header" href="#captcha">Captcha</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><em>WARNING: Captcha's are being heavily churned/rewritten into a new Lua plugin</em></p>
<p>A CAPTCHA is a security measure that can be used to try and filter out the more basic and spammy bots from accessing your server. It presents a challenge that users must complete to prove they are human. This can help protect your server from unwanted automated access and ensure that real users can interact with your community. <strong>Note that CAPTCHA's are NOT foolproof and that more sophistiated bots may still bypass them.</strong></p>
<p>Of course, with the current landscape with AI everywhere, just serving a single CAPTCHA type (or config) does not really work. Furthermore, AntiRaid recognizes that different servers have different needs. Therefore, we provide a flexible CAPTCHA system, fully integrated with our Lua Templating system that allows you to completely customize the CAPTCHA experience for your users. This occurs through filters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<h2 id="sample-captcha"><a class="header" href="#sample-captcha">Sample CAPTCHA</a></h2>
<pre><code class="language-lua">local interop = require "@antiraid/interop"
local img_captcha = require "@antiraid/img_captcha"

local captcha_config = {}

-- Basic options
captcha_config.char_count = 7
captcha_config.filters = {}
setmetatable(captcha_config.filters, interop.array_metatable) -- Filters is an array
captcha_config.viewbox_size = { 280, 160 }
setmetatable(captcha_config.viewbox_size, interop.array_metatable) -- Viewbox size is a tuple

-- Add noise filter
local noise_filter = {
    filter = "Noise",
    prob = 0.05
}

table.insert(captcha_config.filters, noise_filter)

-- Add wave filter
local wave_filter = {
    filter = "Wave",
    f = 4.0, -- Frequency
    amp = 20.0, -- Amplitude
    d = "horizontal" -- Direction
}

table.insert(captcha_config.filters, wave_filter)

-- Add grid filter
local grid_filter = {
    filter = "Grid",
    x_gap = 10,
    y_gap = 30
}

table.insert(captcha_config.filters, grid_filter)

-- Add line filter
local line_filter = {
    filter = "Line",
    p1 = setmetatable({ 0.0, 0.0 }, interop.array_metatable),
    p2 = setmetatable({ 30.0, 100.0 }, interop.array_metatable),
    thickness = 7.0,
    color = setmetatable({ 0, 0, 0 }, interop.array_metatable)
}

table.insert(captcha_config.filters, line_filter)

-- Add color invert filter
local color_invert_filter = {
    filter = "ColorInvert"
}

table.insert(captcha_config.filters, color_invert_filter)

-- Add random line filter
local random_line_filter = {
    filter = "RandomLine"
}

table.insert(captcha_config.filters, random_line_filter)

local captcha = img_captcha.new(captcha_config)

return captcha
</code></pre>
<h2 id="captcha-with-increasing-char-count-with-maximum-of-5-tries-per-user"><a class="header" href="#captcha-with-increasing-char-count-with-maximum-of-5-tries-per-user">CAPTCHA with increasing char count with maximum of 5 tries per user</a></h2>
<pre><code class="language-lua">local args, token = ...
local interop = require "@antiraid/interop"
local img_captcha = require "@antiraid/img_captcha"

local captcha_config = {}

-- Check __stack.users
if __stack._captcha_user_tries == nil then
    __stack._captcha_user_tries = {} -- Initialize users table
end

-- Check __stack._captcha_user_tries[args.user.id]
if __stack._captcha_user_tries[args.user.id] == nil then
    __stack._captcha_user_tries[args.user.id] = 0 -- Initialize user's try count
end

-- Check if user has reached maximum tries
if __stack._captcha_user_tries[args.user.id] &gt;= 5 then
    return { __error = "You have reached the maximum number of tries in this 5 minute window."}
end

-- Basic options
captcha_config.char_count = math.min(7 + __stack._captcha_user_tries[args.user.id], 10) -- Increment the number of characters

captcha_config.filters = {}
setmetatable(captcha_config.filters, interop.array_metatable) -- Filters is an array
captcha_config.viewbox_size = { 280, 160 }
setmetatable(captcha_config.viewbox_size, interop.array_metatable) -- Viewbox size is a tuple

-- Increment the maximum number of tries
__stack._captcha_user_tries[args.user.id] += 1

captcha = img_captcha.new(captcha_config)
return captcha
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lockdowns"><a class="header" href="#lockdowns">Lockdowns</a></h1>
<p>Lockdowns are a way to allow restricting (or 'locking down') specific channels or roles within a server when under an attack or other such crises.</p>
<h2 id="migrating-from-other-bots"><a class="header" href="#migrating-from-other-bots">Migrating from other bots</a></h2>
<p>If you are coming from Wick or another anti-nuke bot like Wick, please note that AntiRaid's lockdown functionality only applies to locking down channels and roles. This means that the following Wick features are not present in AntiRaid lockdowns and are instead part of other more appropriate modules as listed below:</p>
<ul>
<li>Join Auto Kick (present in Inspector Auto Response Member Join)</li>
<li>Join Auto Ban (present in Inspector Auto Response Member Join)</li>
<li>Role Lockdown (WIP, not yet implemented)</li>
<li>All / Server Wide (Most likely will not be implemented)</li>
</ul>
<p>Note that blind lockdowns are not yet implemented in Anti-Raid.</p>
<p>For the sake of comparisons, here is how each lockdown mode compares to Wick's lockdown modes:</p>
<ul>
<li>Quick Server Lockdown (<code>qsl</code>) -&gt; Wick's Channels (<code>sc</code>) lockdown (general performance+requirements for use should be the same as Wick's lockdown feature)</li>
<li>Traditional Server Lockdown (<code>tsl</code>) -&gt; No equivalent in Wick</li>
<li>Single-Channel Lockdown (<code>scl</code>) -&gt; Wick's Channel (<code>c</code>) lockdown (note that locking down multiple specific channels at once is not yet implemented in AntiRaid)</li>
</ul>
<h2 id="usage-notes"><a class="header" href="#usage-notes">Usage Notes</a></h2>
<p>If you want to know more details on each type of lockdown, how they are applied and how multiple lockdown conflicts are resolved, please refer to the <a href="user/lockdown/../../dev/rust_bot_modules_lockdown/README.html">dev docs for lockdown</a></p>
<h2 id="member-roles"><a class="header" href="#member-roles">Member Roles</a></h2>
<p>When you first setup lockdown for the first time, you will be prompted for a set of member roles like below:</p>
<p><img src="user/lockdown/1-lockdowns-memberroles.png" alt="picture of member roles screen in settings page" /></p>
<p>These roles are what AntiRaid will actually lock-down which is why they are also known as 'critical roles'.</p>
<h2 id="quick-server-lockdowns"><a class="header" href="#quick-server-lockdowns">Quick Server Lockdowns</a></h2>
<p>For servers that can meet its restrictions, a quick server lockdown is the fastest way to lockdown your server in a raid. It is recommended to use this lockdown mode if possible. When using this mode, it is important to note one critical requirement:</p>
<ul>
<li>All critical roles must have View Channel and Send Messages. All other roles must not have View Channel and Send Messages.</li>
</ul>
<p>What this looks like is something like the following:</p>
<p><img src="user/lockdown/1-lockdowns-criticalroles1.png" alt="Picture of a normal role" />
<em>Figure 1 shows a normal role without View Channel of Send Messages permissions</em></p>
<p><img src="user/lockdown/1-lockdowns-criticalroles2.png" alt="Picture of a critical role" />
<em>Figure 2 shows a critical role with View Channel and Send Messages permissions</em></p>
<p>The above two figures are how you want to configure your critical/member and normal roles. Basically, turn off View Channel and Send Messages for all your normal roles and turn it on for your critical/member roles you set up earlier in the settings for lockdown.</p>
<p>To make a quick server lockdown, you can use the <code>qsl</code> type. For example, to lock down a server, you can use the following slash command:</p>
<pre><code>/lockdown lock type:qsl reason:There is a raid going on
</code></pre>
<h2 id="traditional-server-lockdown"><a class="header" href="#traditional-server-lockdown">Traditional Server Lockdown</a></h2>
<p>Traditional Server Lockdown is a more traditional lockdown method. It is more flexible than Quick Server Lockdown as it has no required prior setup. However, it is much slower and should be avoided if possible.</p>
<p><strong>WARNING:</strong> Super large servers may have outages when using a traditional server lockdown that a quick server lockdown may not lead to.</p>
<p>To make a traditional server lockdown, you can use the <code>tsl</code> type. For example, to lock down a server, you can use the following slash command:</p>
<pre><code>/lockdown lock type:tsl reason:There is a raid going on
</code></pre>
<h2 id="single-channel-lockdown"><a class="header" href="#single-channel-lockdown">Single-Channel Lockdown</a></h2>
<p>In some cases, only a single channel needs to be locked down. In such a case, a single-channel lockdown is needed.</p>
<p>To make a single-channel lockdown, you can use the <code>scl</code> type. For example, to lock down a server, you can use the following slash command:</p>
<pre><code>/lockdown lock type:scl/&lt;channel_id&gt; reason:There is a raid going on
</code></pre>
<p>Where <code>&lt;channel_id&gt;</code> is the ID of the channel to lockdown.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modifiers"><a class="header" href="#modifiers">Modifiers</a></h1>
<p>There are many cases where you want to either target or override settings for users/channels/roles/globally/other targets. This is where modifiers come in. Modifiers can be used to target users/channels/role/globally.</p>
<p>Each modifier is a string that can be used to target a specific user, channel, role, or globally. The following modifiers are available:</p>
<ul>
<li><strong>User ID</strong> - target a specific user (<code>user/{id}</code>, specificity = <code>3</code>)</li>
<li><strong>Channel ID</strong> - target a specific channel (<code>channel/{id}</code>, specificity = <code>2</code>)</li>
<li><strong>Role ID</strong> - target a specific role (<code>role/{id}</code>, specificity = <code>1</code>)</li>
<li><strong>Custom Variable</strong> - target a specific variable (<code>custom/{key}/{value}/{specificity}</code>, specificity = <code>{specificity}</code>)</li>
<li><strong>Global</strong> - target everything globally (guild-wide) (<code>global</code>, specificity = <code>0</code>)</li>
</ul>
<p>To allow handling conflicts between modifiers, each modifier has a specificity which is essentially a number as seen above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backups"><a class="header" href="#backups">Backups</a></h1>
<h2 id="whats-backed-up"><a class="header" href="#whats-backed-up">What's backed up</a></h2>
<p>Guild structure (roles/channels/name/icon/other settings), some messages (Discord has limits here) and attachments (within reasonable limits).</p>
<h2 id="whats-not-backed-up"><a class="header" href="#whats-not-backed-up">What's not backed up?</a></h2>
<p>Members and bots. Note that for members, we have something coming up <em>soon</em> that may allow you to 'backup/restore' (with consent + regularly re-providing consent) members.</p>
<p>Note that new discord features may also not be backed up/restored immediately on release.</p>
<h2 id="more-details"><a class="header" href="#more-details">More details</a></h2>
<p>See the <a href="user/backups/../../dev/go_jobs/backups.html">dev guide</a> to learn more about the format</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go-jobserver"><a class="header" href="#go-jobserver">Go Jobserver</a></h1>
<p>The Go Jobserver handles server backups, message prunes and other long running tasks on a server</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backups-1"><a class="header" href="#backups-1">Backups</a></h1>
<p><strong>Note that this document describes the technical details of the backup system</strong></p>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<p>A backup is an <a href="dev/go_jobs/iblfile">https://github.com/infinitybotlist/iblfile</a> with the standard <code>AutoEncryptedFile</code> format and has the following fields:</p>
<ul>
<li><code>backup_opts</code> - JSON containing a <code>types.BackupCreateOpts</code> object</li>
<li><code>core/guild</code> - The core guild data (<code>discordgo.Guild</code>)</li>
<li><code>assets/{asset_name}</code> - The guild icon data (<code>[]byte</code>)</li>
<li><code>messages/{channel_id}</code> - The messages in a channel along with basic attachment metadata (<code>[]types.BackupMessage</code>).</li>
<li><code>dbg/*</code> - Debug information. This may vary across backups and <strong>MUST NOT</strong> be used in restoring a backup.</li>
<li><code>attachments/{attachment_id}</code> - The attachments data itself</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="definitions"><a class="header" href="#definitions">Definitions</a></h1>
<ul>
<li>Critical Roles: the roles which are given to members and should hence be locked down. In essence, one can define a set of critical roles (hence the name) which are either the critical roles and defaults to the <code>@everyone</code> role if not set.</li>
</ul>
<h1 id="lockdown-types"><a class="header" href="#lockdown-types">Lockdown Types</a></h1>
<h2 id="quick-server-lockdown"><a class="header" href="#quick-server-lockdown">Quick Server Lockdown</a></h2>
<h3 id="specificity"><a class="header" href="#specificity">Specificity</a></h3>
<ul>
<li><code>0</code> (Lowest specificity)</li>
</ul>
<h3 id="rationale"><a class="header" href="#rationale">Rationale</a></h3>
<p>Quickly lockdown a server as fast as possible</p>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<ul>
<li><code>qsl</code></li>
</ul>
<h3 id="description"><a class="header" href="#description">Description</a></h3>
<p>Quick Lockdown allows for quickly locking down a server given the following permission overwrite setup:</p>
<ul>
<li>All critical roles must have View Channel and Send Messages. All other roles must not have View Channel and Send Messages</li>
</ul>
<p>Internally, <code>qsl</code> modifies only the critical roles to the locked down set of permissions. This requires much fewer API calls and is hence much faster than traditional lockdowns.</p>
<h2 id="traditional-server-lockdown-1"><a class="header" href="#traditional-server-lockdown-1">Traditional Server Lockdown</a></h2>
<h3 id="specificity-1"><a class="header" href="#specificity-1">Specificity</a></h3>
<ul>
<li><code>1</code> (TSL &gt; QSL as it updates all channels in a server)</li>
</ul>
<h3 id="rationale-1"><a class="header" href="#rationale-1">Rationale</a></h3>
<p>In many cases, the requirements for <code>qsl</code> are not feasible for servers to meet. In such a case, a traditional lockdown is needed.</p>
<h3 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h3>
<ul>
<li><code>tsl</code></li>
</ul>
<h3 id="description-1"><a class="header" href="#description-1">Description</a></h3>
<p>Traditional Lockdown is a more traditional lockdown method. It is more flexible than <code>qsl</code> as it has no required prior setup. However, it is much slower and should be avoided if possible.</p>
<p>Internally, <code>tsl</code> works by iterating over all channels and setting the permission overwrites for all critical roles to the locked down set. This is a slow process and can take a long time for large servers. In addition, super large servers may have outages when using a <code>tsl</code> that a <code>qsl</code> may not lead to.</p>
<h2 id="single-channel-lockdown-1"><a class="header" href="#single-channel-lockdown-1">Single-Channel Lockdown</a></h2>
<h3 id="specificity-2"><a class="header" href="#specificity-2">Specificity</a></h3>
<ul>
<li><code>2</code> (SCL &gt; TSL as it updates a single channel)</li>
</ul>
<h3 id="rationale-2"><a class="header" href="#rationale-2">Rationale</a></h3>
<p>In some cases, only a single channel needs to be locked down. In such a case, a single-channel lockdown is needed.</p>
<h3 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h3>
<ul>
<li><code>scl/&lt;channel_id&gt;</code></li>
</ul>
<p>Where <code>&lt;channel_id&gt;</code> is the ID of the channel to lockdown</p>
<h3 id="description-2"><a class="header" href="#description-2">Description</a></h3>
<p>Single-Channel Lockdown is a lockdown method that locks down a single channel.</p>
<p>Internally, <code>scl/&lt;channel_id&gt;</code> works by setting the permission overwrites for all critical roles to the locked down set for the specified channel. This is a fast process and is recommended for locking down a single channel.</p>
<h1 id="specificity-3"><a class="header" href="#specificity-3">Specificity</a></h1>
<p>When multiple lockdowns are made on the same item (which will now be called a <code>handle</code> from now on), there needs to be a way to know what lockdown owns/has the handle. In AntiRaid, this is controlled through specificity based on the rules:</p>
<ul>
<li>Rule 0: When a handle is locked, the priority is added without replacing older priorities. When a handle is unlocked, the priority is removed leading to its previous value.</li>
<li>Rule 1: A handle is controlled unlocked by a lockdown A if the lockdown (say, lockdown B) corresponding to the largest specificity that has locked the handle is less than the specificity of lockdown A. Otherwise, it is considered locked and cannot be modified by lockdown A.</li>
<li>Rule 2: The underlying permissions or permission overwrites of a role/channel are defined as the saved permissions/permission overwrites of the role/channel of the oldest possible lockdown which has saved said data.</li>
</ul>
<p>As an example, consider a case where a <code>tsl</code> is first applied and then an <code>scl/&lt;channel_id&gt;</code>. As per Rule 1, the <code>tsl</code> has a lower specificity than the <code>scl/&lt;channel_id&gt;</code> and so the <code>scl/&lt;channel_id&gt;</code> will also lock the channel handle. When the <code>tsl</code> is then removed, the channel is still locked by <code>scl/&lt;channel_id&gt;</code> which has a greater specificity. Hence, by Rule 1, the <code>scl/&lt;channel_id&gt;</code> locked channel will remain locked even after the <code>tsl</code> is removed as expected.</p>
<p>Next, consider what happens when the <code>scl/&lt;channel_id&gt;</code> is removed. As <code>tsl</code> stores the original channel permission overwrites of all channels and was created before the <code>scl/&lt;channel_id&gt;</code>, Rule 2 applies. Hence, the underlying permissions of the channel is considered to come from the <code>tsl</code>'s stored data and NOT the <code>scl/&lt;channel_id&gt;</code> which was set during the lockdown. This means that when the <code>scl/&lt;channel_id&gt;</code> is removed, the channel will revert to the permissions it had before the <code>tsl</code> was applied which was the original channels permissions.</p>
<p>As such, using Rules 1 and 2, the following holds true:</p>
<p><code>tsl + scl/&lt;channel_id&gt; - tsl - scl/&lt;channel_id&gt; = 0</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="silverpelt"><a class="header" href="#silverpelt">Silverpelt</a></h1>
<p>Silverpelt provides a standard library for all Anti-Raid modules.</p>
<p>To create a new Anti-Raid bot making use of Anti-Raid modules, simply implement the trait <code>silverpelt::module::Module</code>. These modules must then be added to a <code>SilverpeltCache</code> which is then inserted into <code>silverpelt::Data</code>.</p>
<p>Most things in silverpelt are abstracted out through traits or dispatched via events. This allows silverpelt to be used as an abstract interface allowing for Anti-Raid to quickly evolve and change/adapt to different targets.</p>
<p><strong>Note:</strong> AntiRaid uses a event-driven architecture. This means that modules+the main bot process make events that are dispatched to modules. The event system is currently passive (meaning there is no continously running event loop), however this is subject to change in the future.</p>
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<h3 id="sting"><a class="header" href="#sting">Sting</a></h3>
<p>Silverpelt provides concrete structures, utilities and special events for handling stings.</p>
<h3 id="punishments"><a class="header" href="#punishments">Punishments</a></h3>
<p>Silverpelt provides concrete structures, utilities and special events for handling punishments.</p>
<h2 id="stdevents"><a class="header" href="#stdevents">STDEvents</a></h2>
<p>See the <code>rust.stdevent</code> crate first if there's a existing standardized custom event for you to use directly.</p>
<h2 id="some-extra-misc-points"><a class="header" href="#some-extra-misc-points">Some extra misc points</a></h2>
<ul>
<li>
<p>A command is the base unit for access control. This means that all operations with differing access controls must have commands associated with them.</p>
</li>
<li>
<p>This means that all operations (list backup, create/restore backup, delete backup) <em>MUST</em> have associated commands</p>
</li>
<li>
<p>Sometimes, an operation (such as a web-only operation) may not have a module/command associated with it. In such cases, a 'virtual' module should be used. Virtual modules are modules with commands that are not registered via Discord's API. They are used to group commands together for access control purposes and to ensure that each operation is tied to a command</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anti-raid-templating-system"><a class="header" href="#anti-raid-templating-system">Anti-Raid Templating System</a></h1>
<h2 id="supported-languages"><a class="header" href="#supported-languages">Supported Languages</a></h2>
<ul>
<li>Lua (luau / Roblox Lua) - Tier 1</li>
</ul>
<p>Lua is the recommended language for templating</p>
<h2 id="wippotential-languages"><a class="header" href="#wippotential-languages">WIP/Potential Languages</a></h2>
<ul>
<li>JavaScript (see <code>lang_javascript_quickjs</code> and <code>lang_javascript_v8</code> for the current load experiments + integration experiments), potential but unlikely unless someone finds a solution</li>
<li>WebAssembly (potential, not yet decided)</li>
</ul>
<h2 id="language-requirements"><a class="header" href="#language-requirements">Language Requirements</a></h2>
<ol>
<li>All languages must export the following modules/helpers to the extent required as per the templating documentation. (TODO: Improve this spec)</li>
</ol>
<ul>
<li>Messages</li>
<li>Permissions</li>
<li>Captcha</li>
<li>Actions</li>
<li>Key Value API</li>
</ul>
<ol start="2">
<li>All languages must provide a way to sandbox the execution of the code. This is a security requirement. In particular, timeouts and heap/stack/memory limits are required.</li>
<li>Callers must use the abstracted out function calls from <code>lib.rs</code></li>
</ol>
<h2 id="my-language-vent"><a class="header" href="#my-language-vent">My language vent</a></h2>
<p><strong>For reference on my discord vents: https://discord.com/channels/763812938875535361/1040734156327501905/1267195190100361440</strong></p>
<p>Why is lua the only sane language for embedding
V8 has big ffi problems with rust. If you try spawning too many isolates, you have a 100% chance of aborting your process and this issue can only be resolved by performing unsafe void* pointer casts
Quickjs is a bit too slow and poorly documented
Rhai is good but it’s a custom language and it’s sandboxing abilities need unsafe code to fully work (and said unsafe code involves pointer arithmetic that is not thread safe) and heap memory limits require you to manually calculate the heap usage
Tera has virtually no safety features and will gladly execute an infinite recursion
For starlark/skylark, go to the point on rhai but hopefully without the unsafe bits
I can understand now why the game modding industry uses lua, it’s basically the only sane language for handling user input
Lua is legit the only sane scripting language on this entire list</p>
<p>[rhai is not only slower than lua, its sandboxing (i said it above here too in a vent i think) requires actual pointer arithmetic that isnt thread safe, its also a custom lang no one knows while lua is well known in the game community. Luau is used in Roblox games so it caters to Discords target market as well]</p>
<h1 id="template-tokens-1"><a class="header" href="#template-tokens-1">Template Tokens</a></h1>
<p>All lua templates include a special template token in addition to the template arguments. Modules requiring more privileged levels of access (or otherwise require the template state) should require this token and use it to access the required template state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-difference-utilities"><a class="header" href="#text-difference-utilities">Text difference utilities</a></h1>
<p><strong>diff.rs:</strong> Taken from https://docs.rs/text-diff/latest/src/text_diff with some modernizing. All credits go to the author.</p>
<p>Other utilities are taken too. To be documented</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
